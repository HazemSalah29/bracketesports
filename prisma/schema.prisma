// Database schema for the esports platform
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// User Model
model User {
  id          String   @id @default(cuid())
  email       String   @unique
  username    String   @unique
  password    String
  avatar      String?
  firstName   String?
  lastName    String?
  bio         String?
  verified    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastActive  DateTime @default(now())

  // Points and Ranking System
  totalPoints      Int            @default(0)
  currentRank      Rank           @relation(fields: [currentRankId], references: [id])
  currentRankId    String
  rankPoints       Int            @default(0)
  tournamentsWon   Int            @default(0)
  gamesPlayed      Int            @default(0)

  // Virtual Currency
  coinBalance      Int            @default(0)

  // Relationships
  teamMemberships  TeamMember[]
  ownedTeams       Team[]         @relation("TeamOwner")
  tournamentParticipations TournamentParticipant[]
  gamingAccounts   GamingAccount[]
  achievements     UserAchievement[]
  notifications    Notification[]
  sessions         Session[]
  matchStats       PlayerMatchStats[]
  roundStats       PlayerRoundStats[]
  creator          Creator?
  coinTransactions BracketCoin[]

  @@map("users")
}

// Session Model for Authentication
model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// Rank System
model Rank {
  id          String @id @default(cuid())
  tier        String // bronze, silver, gold, platinum, diamond, master, grandmaster
  division    Int    // 1, 2, 3, 4
  minPoints   Int
  maxPoints   Int
  season      String
  
  users       User[]

  @@unique([tier, division, season])
  @@map("ranks")
}

// Gaming Account Links
model GamingAccount {
  id          String @id @default(cuid())
  userId      String
  platform    String // steam, riot, epic, psyonix
  platformId  String
  username    String
  verified    Boolean @default(false)
  createdAt   DateTime @default(now())
  
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([platform, platformId])
  @@map("gaming_accounts")
}

// Teams
model Team {
  id          String   @id @default(cuid())
  name        String   @unique
  tag         String   @unique
  description String?
  avatar      String?
  isPublic    Boolean  @default(true)
  maxMembers  Int      @default(5)
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  owner       User     @relation("TeamOwner", fields: [ownerId], references: [id])
  members     TeamMember[]
  tournamentParticipations TournamentParticipant[]
  wonMatches  TournamentMatch[]

  @@map("teams")
}

// Team Membership
model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  userId    String
  role      String   @default("member") // member, captain, owner
  joinedAt  DateTime @default(now())

  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@map("team_members")
}

// Tournaments
model Tournament {
  id                    String   @id @default(cuid())
  name                  String
  description           String
  game                  String
  gameIcon              String?
  pointsReward          Int
  sponsoredBy           String?
  maxParticipants       Int
  currentParticipants   Int      @default(0)
  startDate             DateTime
  endDate               DateTime
  registrationDeadline  DateTime
  status                String   @default("registering") // registering, live, completed, cancelled
  rules                 String? // JSON string for rules
  tournamentType        String   // solo, team
  teamSize              Int?
  skillRequirement      Json?    // Store rank requirements
  isPrivate             Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Creator Tournament Fields
  creatorId             String?
  creator               Creator? @relation(fields: [creatorId], references: [id])
  entryFeeCoin          Int?     // Entry fee in Bracket Coins
  isCreatorTournament   Boolean  @default(false)
  
  // Prize Structure (Creator-Defined)
  prizeType             PrizeType @default(EXPERIENCE)
  prizeDescription      String?  // Creator's description of what winners get
  cashPrizePool         Float?   // Optional cash prize (creator's responsibility)
  coinPrizePool         Int?     // Optional coin prize
  experiencePrize       String?  // Description of experience-based rewards

  participants          TournamentParticipant[]
  rewards               TournamentReward[]
  customLobbies         CustomGameLobby[]
  matches               TournamentMatch[]
  coinTransactions      BracketCoin[]

  @@map("tournaments")
}

// Tournament Participation
model TournamentParticipant {
  id           String @id @default(cuid())
  tournamentId String
  userId       String?
  teamId       String?
  position     Int?
  pointsEarned Int    @default(0)
  joinedAt     DateTime @default(now())

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user         User?      @relation(fields: [userId], references: [id], onDelete: Cascade)
  team         Team?      @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, userId])
  @@unique([tournamentId, teamId])
  @@map("tournament_participants")
}

// Tournament Rewards
model TournamentReward {
  id           String @id @default(cuid())
  tournamentId String
  position     Int
  points       Int
  badges       Json?

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, position])
  @@map("tournament_rewards")
}

// Achievements System
model Achievement {
  id          String @id @default(cuid())
  name        String @unique
  description String
  icon        String
  type        String // tournament, milestone, special
  rarity      String // common, rare, epic, legendary
  criteria    Json   // Conditions to unlock

  userAchievements UserAchievement[]

  @@map("achievements")
}

// User Achievements
model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime @default(now())

  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@map("user_achievements")
}

// Notifications
model Notification {
  id        String   @id @default(cuid())
  userId    String
  title     String
  message   String
  type      String   // tournament, team, achievement, system
  data      Json?    // Additional data
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

// Custom Game Lobby Model
model CustomGameLobby {
  id            String   @id @default(cuid())
  tournamentId  String
  gameMode      String   // VALORANT, LEAGUE_OF_LEGENDS
  lobbyId       String   @unique
  password      String
  mapId         String?
  teamSize      Int      @default(5)
  maxPlayers    Int      @default(10)
  status        String   @default("CREATED") // CREATED, IN_PROGRESS, COMPLETED, CANCELLED
  gameSettings  Json?    // Custom game configuration
  createdAt     DateTime @default(now())
  startedAt     DateTime?
  completedAt   DateTime?

  tournament    Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  matches       TournamentMatch[]

  @@map("custom_game_lobbies")
}

// Tournament Match Tracking
model TournamentMatch {
  id              String   @id @default(cuid())
  tournamentId    String
  lobbyId         String?
  riotMatchId     String?  // Match ID from Riot API
  gameMode        String   // VALORANT, LEAGUE_OF_LEGENDS
  mapId           String?
  mapName         String?
  status          String   @default("SCHEDULED") // SCHEDULED, IN_PROGRESS, COMPLETED, CANCELLED
  teamAScore      Int      @default(0)
  teamBScore      Int      @default(0)
  winnerTeamId    String?
  gameLengthMs    Int?
  gameStartTime   DateTime?
  gameEndTime     DateTime?
  createdAt       DateTime @default(now())

  tournament      Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  lobby           CustomGameLobby? @relation(fields: [lobbyId], references: [id])
  winnerTeam      Team? @relation(fields: [winnerTeamId], references: [id])
  rounds          MatchRound[]
  playerStats     PlayerMatchStats[]

  @@map("tournament_matches")
}

// Match Round Tracking (Valorant specific)
model MatchRound {
  id              String   @id @default(cuid())
  matchId         String
  roundNumber     Int
  winningTeam     String   // "TeamA" or "TeamB"
  roundResult     String   // "Elimination", "Defuse", "Detonate", etc.
  roundCeremony   String?  // "CeremonyDefault", "CeremonyCloser", etc.
  bombPlanter     String?  // Player PUUID
  bombDefuser     String?  // Player PUUID
  plantSite       String?  // "A", "B", "C"
  defusedInTime   Boolean?
  roundLengthMs   Int?

  match           TournamentMatch @relation(fields: [matchId], references: [id], onDelete: Cascade)
  playerStats     PlayerRoundStats[]

  @@map("match_rounds")
}

// Player Match Statistics
model PlayerMatchStats {
  id              String   @id @default(cuid())
  matchId         String
  userId          String
  puuid           String   // Riot PUUID
  teamSide        String   // "TeamA" or "TeamB"
  characterId     String?  // Agent/Champion ID
  kills           Int      @default(0)
  deaths          Int      @default(0)
  assists         Int      @default(0)
  score           Int      @default(0)
  damageDealt     Int      @default(0)
  damageReceived  Int      @default(0)
  headshotPct     Float?   // Headshot percentage (Valorant)
  firstBloods     Int      @default(0)
  clutches        Int      @default(0)
  aces            Int      @default(0)
  economySpent    Int?     // Credits spent (Valorant)
  
  match           TournamentMatch @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  roundStats      PlayerRoundStats[]

  @@map("player_match_stats")
}

// Player Round Statistics (Valorant)
model PlayerRoundStats {
  id            String   @id @default(cuid())
  roundId       String
  matchStatsId  String
  userId        String
  kills         Int      @default(0)
  damage        Int      @default(0)
  stayed        Boolean  @default(true) // Did not disconnect
  economySpent  Int      @default(0)
  weapon        String?  // Primary weapon used
  armor         String?  // Armor type
  
  round         MatchRound @relation(fields: [roundId], references: [id], onDelete: Cascade)
  matchStats    PlayerMatchStats @relation(fields: [matchStatsId], references: [id], onDelete: Cascade)
  user          User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("player_round_stats")
}

// Content Creator Program Models
model Creator {
  id          String   @id @default(cuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id])
  
  // Creator Details
  handle      String   @unique
  tier        CreatorTier @default(EMERGING)
  status      CreatorStatus @default(PENDING)
  
  // Social Media
  twitchUrl   String?
  youtubeUrl  String?
  tiktokUrl   String?
  discordUrl  String?
  followerCount Int     @default(0)
  
  // Revenue & Analytics
  totalEarnings Float   @default(0)
  revenueShare  Int     @default(60) // Percentage
  
  // Verification
  appliedAt   DateTime @default(now())
  verifiedAt  DateTime?
  rejectedAt  DateTime?
  rejectionReason String?
  
  // Relations
  tournaments Tournament[]
  payouts     CreatorPayout[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("creators")
}

model BracketCoin {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  
  amount      Int      // Coin amount (positive for purchases/winnings, negative for spending)
  type        CoinTransactionType
  status      TransactionStatus @default(PENDING)
  
  // Purchase Details (for purchases)
  dollarAmount Float?
  paymentId   String?  // Stripe payment intent ID
  
  // Tournament Details (for spending)
  tournamentId String?
  tournament  Tournament? @relation(fields: [tournamentId], references: [id])
  
  // Metadata
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("bracket_coins")
}

model CreatorPayout {
  id          String   @id @default(cuid())
  creatorId   String
  creator     Creator  @relation(fields: [creatorId], references: [id])
  
  amount      Float
  status      PayoutStatus @default(PENDING)
  period      String   // "2025-01", "2025-02" etc.
  
  // Payment Details
  paymentMethod String? // "stripe", "paypal"
  paymentId   String?
  paidAt      DateTime?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("creator_payouts")
}

// Enums
enum CreatorTier {
  EMERGING    // 10K-50K followers - 60% share
  RISING      // 50K-250K followers - 65% share
  PARTNER     // 250K-1M followers - 70% share
  ELITE       // 1M+ followers - 75% share
}

enum CreatorStatus {
  PENDING
  APPROVED
  REJECTED
  SUSPENDED
}

enum PrizeType {
  EXPERIENCE    // Coaching, content features, community access
  COINS         // Platform coins (redeemable)
  CASH          // Direct cash from creator
  MERCHANDISE   // Physical items
  HYBRID        // Combination of above
}

enum CoinTransactionType {
  PURCHASE
  TOURNAMENT_ENTRY
  TOURNAMENT_REFUND
  PRIZE_WINNING
  BONUS
  TRANSFER
  REDEMPTION
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
